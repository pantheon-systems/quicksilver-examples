#!/usr/bin/env php
<?php

//
// Usage:
//
//    $ secrets sitename test key value
//
//    Write "value" into "key" in the "test" environment of "sitename".
//
//    $ secrets sitename test key
//
//    Print current value of "key" in the "test" environment of "sitename".
//
//    $ secrets sitename test
//
//    Print all available keys in the "test" environment of "sitename"
//
$self = array_shift($argv);
$self_name = basename($self);

// Minimum required arguments is two.
if (count($argv) < 2) {
  print("Usage: $self_name sitename test [key [value]]\n");
  exit(1);
}

// Get site and env
$site = array_shift($argv);
$env = array_shift($argv);

// Get sftp command for site and env
$cmd = "terminus site connection-info --env=$env --site=$site --field=sftp_command";
// print "cmd is $cmd\n";

$sftp_command = `$cmd`;
//print "sftp command is $sftp_command\n";
if (empty($sftp_command)) {
  exit(1);
}

// Make a temporary directory and chdir there
global $workdir;
$workdir = tempdir();
// print("workdir is $workdir\n");

// Insure that $workdir will be deleted on exit.
register_shutdown_function('cleanup_function');
chdir($workdir);

// Fetch secrets.json, if it exists
exec("(echo 'cd files' && echo 'cd private' && echo 'get secrets.json') | $sftp_command", $fetch_output, $fetch_status);
if ($fetch_status) {
  exit($fetch_status);
}

$secret_values = array();
if (file_exists("secrets.json")) {
  $secrets = file_get_contents("secrets.json");
  $secret_values = (array)json_decode($secrets);
  // print "secrets are:\n";
  // var_export($secret_values);
  // print "\n";
}

// Two arguments: print all available keys
if (empty($argv)) {
  if (empty($secret_values)) {
    print "No secrets defined.\n";
    exit(1);
  }
  else {
    print "\nAvailable secret keys:\n";
    print implode("\n", array_keys($secret_values)) . "\n";
  }
  exit(0);
}

// Three arguments: print current value of key
$key = array_shift($argv);
if (empty($argv)) {
  if (!array_key_exists($key, $secret_values)) {
    print "$key not defined in secrets.\n";
    exit(1);
  }
  print "$key:\n{$secret_values[$key]}\n";
  exit(0);
}

// Four arguments: set value of key
$value = array_shift($argv);

// If there are no secret values, then try to create the 'private' directory,
// just to be sure.
if (empty($secret_values)) {
  exec("(echo 'cd files' && echo '-mkdir private') | $sftp_command > /dev/null 2>&1");
}

// Write the updated secrets file to working directory.
$secret_values[$key] = $value;
file_put_contents("secrets.json", json_encode($secret_values));

// Upload secrets.json, if possible
exec("(echo 'cd files' && echo 'cd private' && echo 'put secrets.json') | $sftp_command", $upload_output, $upload_status);
if ($uplaod_status) {
  exit($upload_status);
}

print "Set secret key $key to $value\n";
exit(0);


// Create a temporary directory
function tempdir($dir=FALSE, $prefix='php') {
  $tempfile=tempnam($dir ? $dir : sys_get_temp_dir(), $prefix ? $prefix : '');
  if (file_exists($tempfile)) {
    unlink($tempfile);
  }
  mkdir($tempfile);
  if (is_dir($tempfile)) {
    return $tempfile;
  }
}

// Recursively remove directories
function rrmdir($dir) {
   if (is_dir($dir)) {
     $objects = scandir($dir);
     foreach ($objects as $object) {
       if ($object != "." && $object != "..") {
         if (is_dir($dir."/".$object))
           rrmdir($dir."/".$object);
         else
           unlink($dir."/".$object);
       }
     }
     rmdir($dir);
   }
}

// Delete our work directory on exit.
function cleanup_function() {
  global $workdir;
  rrmdir($workdir);
}

